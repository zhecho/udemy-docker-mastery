
*******************************************************************************
*                                Docker Notes                                 *
*******************************************************************************
 Linux installation check official docker documantation
  Install docker  and check with version
    $ docker version
    Client: Docker Engine - Community
     Version:           19.03.5
     API version:       1.40
     Go version:        go1.12.12
     Git commit:        633a0ea838
     Built:             Wed Nov 13 07:29:52 2019
     OS/Arch:           linux/amd64
     Experimental:      false
    
    Server: Docker Engine - Community
     Engine:
      Version:          19.03.5
      API version:      1.40 (minimum version 1.12)
      Go version:       go1.12.12
      Git commit:       633a0ea838
      Built:            Wed Nov 13 07:28:22 2019
      OS/Arch:          linux/amd64
      Experimental:     false
     containerd:
      Version:          1.2.10
      GitCommit:        b34a5c8af56e510852c35414db4c1f4fa6172339
     runc:
      Version:          1.0.0-rc8+dev
      GitCommit:        3e425f80a8c931f88e6d94a8c831b9d5aa481657
     docker-init:
      Version:          0.18.0
      GitCommit:        fec3683
     zen0@42 ~/prj/udemy-docker-mastery (master

  Install docker-machine & docker-compose and check versions with:
    - docker-machine version
        $ docker-machine version
        docker-machine version 0.16.2, build bd45ab13
         zen0@42 ~/prj/udemy-docker-mastery (master)
    - docker-compose version
        $ docker-compose version
        docker-compose version 1.25.1, build a82fef07
        docker-py version: 4.1.0
        CPython version: 3.7.4
        OpenSSL version: OpenSSL 1.1.0l  10 Sep 2019
         zen0@42 ~/prj/udemy-docker-mastery (master)
        $

 - Run nginx container in foreground 
    $ docker container run --publish 80:80 nginx
 - Run nginx container in background
    $ docker container run --publish 80:80 --detach nginx
 - List of running containers 
    $ docker container ls 
 - Stop running docker with "stop" and first unique numbers of ID
    $ docker container ls
    $ docker stop 15b
 - Specify container name with "--name"
    $ docker container run --publish 80:80 --detach --name webhost nginx
 - Show Logs on webhost container
    $ docker container logs webhost
 - List running processes on webhost container 
    $ docker container top webhost
 - List all available commands 
    $ docker container --help
 - Remove Non-running containers 
    $ docker container rm <id1> <id2> ....
 - Remove running containers  "-f" - force
    $ docker container rm -f <id1> <id2> ....
 - List available images
    $ docker image ls


 Assignment: Manage multiple Containers
    -d - detach
    -e - (--env) assign environment variables 
    --help - check all help

 Running MySQL with random root password and check logs
    $ docker container run --publish 127.0.0.1:3306:3306 -d --name db -e MYSQL_RANDOM_ROOT_PASSWORD=yes mysql
    $ docker container run --name webserver -p 127.0.0.1:8080:80 -d nginx


 Container processes
    $ docker container top db
     
 Container Metadata configuration - check how container is started 
    $ docker container inspect db
    
 Container Stats - check container performance / stats
    $ docker container stats


*************************************
*  Getting Shell inside Containers  *
*************************************
    -i - interactive
    -t - tty
    # start bash
    $ docker container run -it --name proxy nginx bash

    # start basic ubuntu dist 
    $ docker container run -it --name ubuntu ubuntu


    # running the same instance 
    $ docker container start -ai ubuntu

    # run command on running container
    $ docker container exec -it db bash

 Using Alpine image
    $ docker pull alpine
    $ docker container run -it alpine

    # using apk package manager of alpine 

    $ docker container inspect --format '{{ .NetworkSettings.IPAddress }}' lala

*************************************
*  Docker Network Concepts and CLI  *
*************************************
 bridge  - default nated network trough the host ip

 CLI
    $ docker network ls
    $ docker network inspect
    $ docker network create --driver
    $ docker network connect
    $ docker network disconnect

 Show bridge configuration 
    $ docker network inspect bridge

 Create network my_net
    $ docker network create my_net
    
 Attach container to network 
    $ docker container run --name nginx -d --network my_net nginx
    # show network config
    $ docker network inspect my_net
    
    # attach containers to network II way     
    $ docker network connect my_net lala
    $ docker network connect my_net nginx


*********************************
*  Assignment: CLI APP Testing  *
*********************************

  docker container run --name ubuntu -d -it ubuntu:14.04 bash
    apt update && apt install curl
  docker container run --name centos -d -it centos:7 bash 
    yum install curl

**************************************
*  Assignment: DNS round robin Test  *
**************************************
  docker network create net1
  docker container run -d --net net1 --network-alias lala elasticsearch:2
  docker container run -d --net net1 --network-alias lala elasticsearch:2

  docker container run --net net1 -it ubuntu 
    apt update && apt install -y dnsutils iputils-ping curl 
    dig lala
    ping lala - check out ip 
    ping lala - check out returing ip 
    curl -s lala:9200 
    curl -s lala:9200 

 Attach/Detach to container process
    docker container attach <cont_name>
    Ctrl + p + Ctrl + q - detach from container without exit 
    Ctrl + c / Ctrl + D - detach and exit

*******************************************************************************
*                              Container Images                               *
*******************************************************************************

Images are made up of file system changes and metadata
Each Layer is identified and only stored Once in the host 
COW - Copy on Write 

hub.docker.org
https://github.com/docker-library/official-images

  docker pull nginx
  docker pull nginx:1.11.9
  docker pull nginx:1.11.9-alpine

  docker image ls

History of the Container layers
  docker history ubuntu:latest
  docker history nginx:latest

Inspect -- show Metadata how this image will run 
  docker image inspect nginx


Login to hub.docker.com (after sign up and make token)
  docker login --username
  docker logout

Images, tag, etc.
  docker image tag --help
  docker image tag nginx bredfisher/nginx - copy original to bredfisher/..
  docker image tag bredfisher/nginx bredfisher/nginx:lala
  docker image push bredfisher/nginx:lala - push to hub.docker.com

*******************************************************************************
*                               Building Images                               *
*******************************************************************************

  docker build -f some-docker-file

Docker file:
  FROM      - based on some of: debian:jessie | scratch | alpine:latest | ....
  ENV       - to pass environment variables in the image
  RUN       - build and execute some layers in the image like move all logs to
/dev/stdout and /dev/sdterr and other
  EXPOSE    - expose these ports on the docker virtual network
  CMD       - required: run this command when container is launched; only one
CMD allowed, so if there are multiple, last one wins
  WORKDIR   - change working directory to root of nginx webhost using WORKDIR
is preferred to using 'RUN cd /some/path'
  COPY      - copy local files to image 

Building from docker file:
  docker image build -t custom_image .


**************************************
*  Assignment: Build Your Own Image  *
**************************************

Check out dockerfile-assignment-1/Dockerfile


Cleaning
- docker image prune     - to clean up just "dangling" images
- docker system prune    - will clean up everything
- docker image prune -a  - which will remove all images you're not using.
- docker system df       - to see space usage.


*******************************************************************************
*                   Container Lifetime & Persistent Data 5                    *
*******************************************************************************


******************************
*  Persistent Data: Volumes  *
******************************

Docker file :
 NOTE: Volumes is not auto-deleted when removing containers 
 VOLUME - create a volume for persistent data


Check mysql container 
 docker pull mysql 
 docker inspect mysql:latest
 docker volume ls
 # get some volume from the above cmd and inspect it 
 docker inspect 1efe97851655ed81695d9744b135dd0da0841a3ae5ef826260627a057fdd79fc
 # You can check "Mountpoint" if you use Linux  or mount it under OSX or Win in
order to check it


Named Volumes
 "-v" - volumes / named volumes

 docker container run -d --name=mysql -v mysql-db:/var/lib/mysql mysql 
 docker volume ls 
 # check volumes name 

**********************************
*  Persistent Data: Bind Mounts  *
**********************************

Mount file or directory to container

Volumes can be defined in:
- Docker file as "VOLUME"
- as named volumes in "run" cmd: 
  ... -v mysql-db:/var/lib/mysql 
- Volumes are not auto-deleted when remove containers 
 docker volumes ls / rm ...

*******************************
*  Assignment: Named Volumes  *
*******************************
 - Database upgrade with containers
 - Create postrgresql with named volume psql-data using version 9.6.1
 - Use Docker Hub to learn VOLUME path
 - Check logs, stop container
 - Create new container with postgresql with save named vol. version 9.6.2 
 - Check logs and validate

$ docker container run --name psql_1 -v psql-data:/var/lib/postgresql/data \
  -e POSTGRES_PASSWORD=`head /dev/urandom | tr -dc A-Za-z0-9 | head -c 20 ;\
   echo ''` postgres:9.6.1

$ docker container logs -f psql_1

$ docker container run --name psql_2 -v psql-data:/var/lib/postgresql/data \
  postgres:9.6.2

$ docker container logs -f psql_2


*****************************
*  Assignment: Bind Mounts  *
*****************************

cd bindmount-sample-1
docker container run --rm -p 80:4000 -v $(pwd):/site bretfisher/jekyll-serve


*******************************************************************************
*                          Section 6: Docker Compose                          *
*******************************************************************************

 - YAML formatted file describe the solution for:
    containers
    networks
    volumes
 - CLI tool docker-compose
    docker-compose.yml          - default filename
    docker-compose -f <file>    - load filename
       
 YAML File config items:
    version: '3.1'  # if no version is specificed then v1 is assumed. Recommend v2 minimum
    services:  # containers. same as docker run
      servicename: # a friendly name. this is also DNS name inside network
        image: # Optional if you use build:
        command: # Optional, replace the default CMD specified by the image
        environment: # Optional, same as -e in docker run
        volumes: # Optional, same as -v in docker run
      servicename2:
    volumes: # Optional, same as docker volume create
    networks: # Optional, same as docker network create

*****************************
*  Docker Compose CLI tool  *
*****************************

Docker compose is using docker API to talk with containers. It have similar
commands

cd compose-sample-2
docker-compose up
docker-compose up -d        - run in backgorund
docker-compose ps           - list running containers
docker-compose top          - show proc
docker-compose down         - destroy everyting


**************************************
*  Assignment: Write a compose file  *
**************************************

# version: '3.1'
version: '2'
# Assignment: Writing a Compose File

# > Goal: Create a compose config for a local Drupal CMS website
# 
# - This empty directory is where you should create a docker-compose.yml 
# - Use the `drupal` image along with the `postgres` image
# - Set the version to 2
# - Use `ports` to expose Drupal on 8080
# - Be sure to setup POSTGRES_PASSWORD on postgres image
# - Walk though Drupal config in browser at http://localhost:8080
# - Tip: Drupal assumes DB is localhost, but it will actually be on the compose
# service name you give it
# - Use Docker Hub documentation to figure out the right environment and volume
# settings
# - Extra Credit: Use volumes to store Drupal unique data

services:
  web:
    image: drupal:8.2
    volumes:
      - drupal-modules:/var/www/html/modules 
      - drupal-profiles:/var/www/html/profiles 
      - drupal-sites:/var/www/html/sites 
      - drupal-themes:/var/www/html/themes 
    ports:
      - '8080:80'
  db:
    image: postgres:9.6
    environment:
      # - POSTGRES_DB=db
      # - POSTGRES_USER=usr
      - POSTGRES_PASSWORD=pwd
    volumes:
      - psql_data:/var/lib/postgresql/data
    ports:
      - '5432:5432'
    
volumes:
  psql_data:
  drupal-modules:
  drupal-profiles:
  drupal-sites:
  drupal-themes:


****************************
*  Using Compose to build  *
****************************
# Build image from nginx.Dockerfile
version: '2'

# based off compose-sample-2, only we build nginx.conf into image
# uses sample site from https://startbootstrap.com/template-overviews/agency/

services:
  proxy:
    build:
      context: .
      dockerfile: nginx.Dockerfile
    ports:
      - '80:80'
  web:
    image: httpd
    volumes:
      - ./html:/usr/local/apache2/htdocs/


 docker-compose build 

***************************************
*  Assignment: Build and Run Compose  *
***************************************
# docker-compose.yml
version: '2'
services:
  web:
    build:
      context: .
      dockerfile: drupal_8_6_custom.Dockerfile
    image: custom-drupal
    volumes:
      - drupal-modules:/var/www/html/modules 
      - drupal-profiles:/var/www/html/profiles 
      - drupal-sites:/var/www/html/sites 
      - drupal-themes:/var/www/html/themes 
    ports:
      - '8080:80'
  db:
    image: postgres:9.6
    environment:
      # - POSTGRES_DB=postgres
      # - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=pwd
    volumes:
      - drupal-data:/var/lib/postgresql/data
    # ports:
      # - '5432:5432'
    
volumes:
  drupal-data:
  drupal-modules:
  drupal-profiles:
  drupal-sites:
  drupal-themes:

**********************************
*  drupal_8_6_custom.Dockerfile  *
**********************************
FROM drupal:8.6
RUN  apt-get update && apt-get install -y git \
     && rm -rf /var/lib/apt/lists/*

WORKDIR /var/www/html/themes

RUN git clone --branch 8.x-3.x --single-branch --depth 1 \
    https://git.drupal.org/project/bootstrap.git \
    && chown -R www-data:www-data bootstrap

WORKDIR /var/www/html


*******************************************************************************
*                                 Section 7:                                  *
*******************************************************************************


***************************************
*  63. Creating 3-node swarm cluster  *
***************************************
- play-with-docker.com
- docker-machine + VBox
- on localhost
    docker-machine create node1  - create node 1 
    docker-machine create node2  - create node 2 
    docker-machine create node3  - create node 3 
    docker-machine env node1     - in order to set env variables
    docker-machine ssh node1     - login via ssh to node 1

    on node1:
    # create swarm manager
    docker swarm init --advertise-addr 192.168.99.100

    # list nodes 
    docker node ls 

    # goto node2 and join him with ... 
    docker swarm join --token SWMTKN-1-5tdfd5350x7pv04kt2hvzhtsy4nxwtavxij07o8eid5x6ag9c0-7rhd58nl0hxnhl4e4k741x16a 192.168.99.100:2377

    Note: Workers is not allowed to list/modify cluster state !! (so docker
node ls command will not work at node2)

    # make node2 manager
    # on node1 execute:
    docker node update --role manager node2

    # to join the manager to the swarm use
    docker swarm join-token manager

    # copy/paste output from above command in order to join the swarm node3
    docker swarm join .....

    # on some manager node execute
    docker service create --replicas 3 alpine ping 8.8.8.8  
    
    # check out running processes 
    docker node ps node1 
    docker node ps node2
    docker node ps node3
    or 
    docker service ps <name>

- Digital ocean + docker install
    create 3 droplets with 10$ price

Use get.docker.com curl in order to run docker on VMs

*******************************************************************************
*             Section 8: Swarm basic futures and How to use Them              *
*******************************************************************************


********************************************************
*  64. Scaling out with Overlay Multi-host Networking  *
********************************************************

Use "--driver overlay" - and it will create "vlan" for container-to-container
traffic inside single swarm
Optional we can use IPsec for that kind of netowrk


 docker network create --driver overlay mydupal
 # on some manager node
 docker service create --name psql --network mydupal \ 
    -e POSTGESQL_PASSWORD=yes postgres:11

 # check it out 
 docker service ls
 docker service ps psql

 # create and check drupal
 docker service create --name drupal --network mydupal -p 80:80 drupal
 docker service ps drupal 

 # watch raising services with :)
 watch docker service ls 


***************************************
*  65: Scaling out with Routing Mesh  *
***************************************
Uses: 
    - IPVS from kernel
    - load balance all services across their Tasks
        - container-to-container overlay network uses virtual IP
    - routes ingress traffic to proper task

 # create elastic search in order to understand routing mesh
 docker service create --name search --replicas=3 -p 9200:9200 elasticsearch:2

 # check with curl the virtual IP with integrated load balancer 
 for i in 3 i++; do curl localhost:9200; done

# Important NOTES !!!
 - Load Balancing method is STATELESS !
 - LB is Layer 3 (TCP) based not Layer 4 (DNS)
 
# Solution for above restrictions 
 - use Nginx or HAproxy
 - use DockerEE with build-in L4 web proxy

***************************************************************
*  66: Assignment: Create a multi-service multi-node web app  *
***************************************************************
  Use README for in swarm-app-1
  Check out file swarm-app-1/swarm-app.sh
 


 














